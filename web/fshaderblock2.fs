uniform highp uint A1;
uniform highp uint B1;
uniform highp uint C1;
uniform highp uint D1;

u32 create_return_from_second_tunnels() {
  u32 res = 0u;
  res = res + tunnel9;
  res = res << 9;
  res = res + tunnel4;
  return res;
}

int Block2(uint id) {

  /* u32 Q[65]; */
  u32 x[16];
  u32 QM0, QM1, QM2, QM3;
  u32 i, itr_q16, itr_q1q2, itr_q9, itr_q4, tmp_q1, tmp_q2, tmp_q4, tmp_q9;
  u32 I, not_I;
  u32 sigma_Q17, sigma_Q19, sigma_Q20, sigma_Q23, sigma_Q35, sigma_Q62;
  u32 Q1_fix, Q2_fix, mask_Q1Q2, Q1Q2_strength;
  u32 AA0, BB0, CC0, DD0, AA1, BB1, CC1, DD1;

  QM3 = A0;
  QM0 = B0;
  QM1 = C0;
  QM2 = D0;

  // Mask generation for tunnel Q9 - 8 bits
  int Q9_mask_bits[] = int[]( 3, 4, 5, 11, 19, 21, 22, 23 );
  int Q9_strength = 8;
  /* const u32 *mask_Q9 = generate_mask(Q9_strength, Q9_mask_bits); */
  const u32 mask_Q9[] = uint[](0u,4u,8u,12u,16u,20u,24u,28u,1024u,1028u,1032u,1036u,1040u,1044u,1048u,1052u,262144u,262148u,262152u,262156u,262160u,262164u,262168u,262172u,263168u,263172u,263176u,263180u,263184u,263188u,263192u,263196u,1048576u,1048580u,1048584u,1048588u,1048592u,1048596u,1048600u,1048604u,1049600u,1049604u,1049608u,1049612u,1049616u,1049620u,1049624u,1049628u,1310720u,1310724u,1310728u,1310732u,1310736u,1310740u,1310744u,1310748u,1311744u,1311748u,1311752u,1311756u,1311760u,1311764u,1311768u,1311772u,2097152u,2097156u,2097160u,2097164u,2097168u,2097172u,2097176u,2097180u,2098176u,2098180u,2098184u,2098188u,2098192u,2098196u,2098200u,2098204u,2359296u,2359300u,2359304u,2359308u,2359312u,2359316u,2359320u,2359324u,2360320u,2360324u,2360328u,2360332u,2360336u,2360340u,2360344u,2360348u,3145728u,3145732u,3145736u,3145740u,3145744u,3145748u,3145752u,3145756u,3146752u,3146756u,3146760u,3146764u,3146768u,3146772u,3146776u,3146780u,3407872u,3407876u,3407880u,3407884u,3407888u,3407892u,3407896u,3407900u,3408896u,3408900u,3408904u,3408908u,3408912u,3408916u,3408920u,3408924u,4194304u,4194308u,4194312u,4194316u,4194320u,4194324u,4194328u,4194332u,4195328u,4195332u,4195336u,4195340u,4195344u,4195348u,4195352u,4195356u,4456448u,4456452u,4456456u,4456460u,4456464u,4456468u,4456472u,4456476u,4457472u,4457476u,4457480u,4457484u,4457488u,4457492u,4457496u,4457500u,5242880u,5242884u,5242888u,5242892u,5242896u,5242900u,5242904u,5242908u,5243904u,5243908u,5243912u,5243916u,5243920u,5243924u,5243928u,5243932u,5505024u,5505028u,5505032u,5505036u,5505040u,5505044u,5505048u,5505052u,5506048u,5506052u,5506056u,5506060u,5506064u,5506068u,5506072u,5506076u,6291456u,6291460u,6291464u,6291468u,6291472u,6291476u,6291480u,6291484u,6292480u,6292484u,6292488u,6292492u,6292496u,6292500u,6292504u,6292508u,6553600u,6553604u,6553608u,6553612u,6553616u,6553620u,6553624u,6553628u,6554624u,6554628u,6554632u,6554636u,6554640u,6554644u,6554648u,6554652u,7340032u,7340036u,7340040u,7340044u,7340048u,7340052u,7340056u,7340060u,7341056u,7341060u,7341064u,7341068u,7341072u,7341076u,7341080u,7341084u,7602176u,7602180u,7602184u,7602188u,7602192u,7602196u,7602200u,7602204u,7603200u,7603204u,7603208u,7603212u,7603216u,7603220u,7603224u,7603228u);

  // Mask generation for MMMM Q4 - 6 bits
  int Q4_mask_bits[] = int[]( 14, 15, 16, 23, 24, 25 );
  int Q4_strength = 6;
  /* const u32 *mask_Q4 = generate_mask(Q4_strength, Q4_mask_bits); */
  const u32 mask_Q4[] = uint[](0u,8192u,16384u,24576u,32768u,40960u,49152u,57344u,4194304u,4202496u,4210688u,4218880u,4227072u,4235264u,4243456u,4251648u,8388608u,8396800u,8404992u,8413184u,8421376u,8429568u,8437760u,8445952u,12582912u,12591104u,12599296u,12607488u,12615680u,12623872u,12632064u,12640256u,16777216u,16785408u,16793600u,16801792u,16809984u,16818176u,16826368u,16834560u,20971520u,20979712u,20987904u,20996096u,21004288u,21012480u,21020672u,21028864u,25165824u,25174016u,25182208u,25190400u,25198592u,25206784u,25214976u,25223168u,29360128u,29368320u,29376512u,29384704u,29392896u,29401088u,29409280u,29417472u);

  // We extract the 32th bit of B0 and its
  I = QM0 & 0x80000000u;
  not_I = (~QM0) & 0x80000000u;

  /* X = mix(id); */

  // Start block 2 generation.
  // TO-DO: add a time limit for collision search.
  /* for (int it = 0; it <= 0; it++) { */
  /* for (i = 0u; i < ((id >> 14u) & 3u); i++){ */
  /*   rng(); */
  /* } */

    // Q[ 1] = ~Ivvv  010v  vv1v  vvv1  .vvv  0vvv  vv0.  ...v
    // RNG   =  .***  ...*  **.*  ***.  ****  .***  **.*  ****  0x71def7dfu
    // 0     =  ....  *.*.  ....  ....  ....  *...  ..*.  ....  0x0a000820u
    // 1     =  ....  .*..  ..*.  ...*  ....  ....  ....  ....  0x04210000u
    Q[1] = (rng() & 0x71def7dfu) + 0x04210000u + not_I;

    // Multi message modif. meth. (MMMM) Q1Q2, Klima
    // Q[ 2] = ~I^^^  110^  ^^0^  ^^^1  0^^^  1^^^  ^^0v  v00^
    // RNG   =  ....  ....  ....  ....  ....  ....  ...*  *...  0x00000018u
    // 0     =  ....  ..*.  ..*.  ....  *...  ....  ..*.  .**.  0x02208026u
    // 1     =  ....  **..  ....  ...*  ....  *...  ....  ....  0x0c010800u
    // Q[ 1] =  .***  ...*  **.*  ***.  .***  .***  **..  ...*  0x71de77c1u
    Q[2] = (rng() & 0x00000018u) + 0x0c010800u + (Q[1] & 0x71de77c1u) + not_I;

    // Q[ 3] = ~I011  111.  ..01  1111  1..0  1vv1  011^  ^111
    // RNG   =  ....  ...*  **..  ....  .**.  .**.  ....  ....  0x01c06600u
    // 0     =  .*..  ....  ..*.  ....  ...*  ....  *...  ....  0x40201080u
    // 1     =  ..**  ***.  ...*  ****  *...  *..*  .**.  .***  0x3e1f8967u
    // Q[ 2] =  ....  ....  ....  ....  ....  ....  ...*  *...  0x00000018u
    Q[3] = (rng() & 0x01c06600u) + 0x3e1f8967u + (Q[2] & 0x00000018u) + not_I;

    // Q[ 4] = ~I011  101.  ..00  0100  ...0  0^^0  0001  0001
    // RNG   =  ....  ...*  **..  ....  ***.  ....  ....  ....  0x01c0e000u
    // 0     =  .*..  .*..  ..**  *.**  ...*  *..*  ***.  ***.  0x443b19eeu
    // 1     =  ..**  *.*.  ....  .*..  ....  ....  ...*  ...*  0x3a040011u
    // Q[ 3] =  ....  ....  ....  ....  ....  .**.  ....  ....  0x00000600u
    Q[4] = (rng() & 0x01c0e000u) + 0x3a040011u + (Q[3] & 0x00000600u) + not_I;

    // Q4 tunnel, Klima, bits 25-23,16-14
    // Q[ 5] =  I100  10.0  0010  1111  0000  1110  0101  0000
    // RNG   =  ....  ..*.  ....  ....  ....  ....  ....  ....  0x02000000u
    // 0     =  ..**  .*.*  **.*  ....  ****  ...*  *.*.  ****  0x35d0f1afu
    // 1     =  .*..  *...  ..*.  ****  ....  ***.  .*.*  ....  0x482f0e50u
    Q[5] = (rng() & 0x02000000u) + 0x482f0e50u + I;

    // Q4 tunnel, Klima, bits 25-23,16-14
    // Q[ 6] =  I..0  0101  1110  ..10  1110  1100  0101  0110
    // RNG   =  .**.  ....  ....  **..  ....  ....  ....  ....  0x600c0000u
    // 0     =  ...*  *.*.  ...*  ...*  ...*  ..**  *.*.  *..*  0x1a1113a9u
    // 1     =  ....  .*.*  ***.  ..*.  ***.  **..  .*.*  .**.  0x05e2ec56u
    Q[6] = (rng() & 0x600c0000u) + 0x05e2ec56u + I;

    // Q[ 7] = ~I..1  0111  1.00  ..01  10.1  1110  00..  ..v1
    // RNG   =  .**.  ....  .*..  **..  ..*.  ....  ..**  ***.  0x604c203eu
    // 0     =  ....  *...  ..**  ..*.  .*..  ...*  **..  ....  0x083241c0u
    // 1     =  ...*  .***  *...  ...*  *..*  ***.  ....  ...*  0x17819e01u
    Q[7] = (rng() & 0x604c203eu) + 0x17819e01u + not_I;

    // Q[ 8] = ~I..0  0100  0.11  ..10  1..v  ..11  111.  ..^0
    // RNG   =  .**.  ....  .*..  **..  .***  **..  ...*  **..  0x604c7c1cu
    // 0     =  ...*  *.**  *...  ...*  ....  ....  ....  ...*  0x1b810001u
    // 1     =  ....  .*..  ..**  ..*.  *...  ..**  ***.  ....  0x043283e0u
    // Q[ 7] =  ....  ....  ....  ....  ....  ....  ....  ..*.  0x00000002u
    Q[8] = (rng() & 0x604c7c1cu) + 0x043283e0u + (Q[7] & 0x00000002u) + not_I;

    // Q9 tunnel plus MMMM-Q12Q11, Klima, prepared, not programmed
    // Q[ 9] = ~Ivv1  1100  0xxx  .x01  0..^  .x01  110x  xx01
    // RNG   =  .**.  ....  .***  **..  .**.  **..  ...*  **..  0x607c6c1cu
    // 0     =  ....  ..**  *...  ..*.  *...  ..*.  ..*.  ..*.  0x03828222u
    // 1     =  ...*  **..  ....  ...*  ....  ...*  **..  ...*  0x1c0101c1u
    // Q[ 8] =  ....  ....  ....  ....  ...*  ....  ....  ....  0x00001000u
    Q[9] = (rng() & 0x607c6c1cu) + 0x1c0101c1u + (Q[8] & 0x00001000u) + not_I;

    // Q9 tunnel plus MMMM-Q12Q11, Klima
    // Q[10] = ~I^^1  1111  1000  v011  1vv0  1011  1100  0000
    // RNG   =  ....  ....  ....  *...  .**.  ....  ....  ....  0x00086000u
    // 0     =  ....  ....  .***  .*..  ...*  .*..  ..**  ****  0x0074143fu
    // 1     =  ...*  ****  *...  ..**  *...  *.**  **..  ....  0x1f838bc0u
    // Q[ 9] =  .**.  ....  ....  ....  ....  ....  ....  ....  0x60000000u
    Q[10] = (rng() & 0x00086000u) + 0x1f838bc0u + (Q[9] & 0x60000000u) + not_I;

    // Q9 tunnel plus MMMM-Q12Q11, Klima
    // Q[11] = ~Ivvv  vvvv  .111  ^101  1^^0  0111  11v1  1111
    // RNG   =  .***  ****  *...  ....  ....  ....  ..*.  ....  0x7f800020u
    // 0     =  ....  ....  ....  ..*.  ...*  *...  ....  ....  0x00021800u
    // 1     =  ....  ....  .***  .*.*  *...  .***  **.*  ****  0x007587dfu
    // Q[10] =  ....  ....  ....  *...  .**.  ....  ....  ....  0x00086000u
    Q[11] = (rng() & 0x7f800020u) + 0x007587dfu + (Q[10] & 0x00086000u) + not_I;

    // MMMM-Q12Q11, Klima
    // Q[12] = ~I^^^  ^^^^  ....  1000  0001  ....  1.^.  ....
    // RNG   =  ....  ....  ****  ....  ....  ****  .*.*  ****  0x00f00f5fu
    // 0     =  ....  ....  ....  .***  ***.  ....  ....  ....  0x0007e000u
    // 1     =  ....  ....  ....  *...  ...*  ....  *...  ....  0x00081080u
    // Q[11] =  .***  ****  ....  ....  ....  ....  ..*.  ....  0x7f000020u
    Q[12] = (rng() & 0x00f00f5fu) + 0x00081080u + (Q[11] & 0x7f000020u) + not_I;

    // Q[13] =  I011  1111  0...  1111  111.  ....  0...  1...
    // RNG   =  ....  ....  .***  ....  ...*  ****  .***  .***  0x00701f77u
    // 0     =  .*..  ....  *...  ....  ....  ....  *...  ....  0x40800080u
    // 1     =  ..**  ****  ....  ****  ***.  ....  ....  *...  0x3f0fe008u
    Q[13] = (rng() & 0x00701f77u) + 0x3f0fe008u + I;

    // Q[14] =  I100  0000  1...  1011  111.  ....  1...  1...
    // RNG   =  ....  ....  .***  ....  ...*  ****  .***  .***  0x00701f77u
    // 0     =  ..**  ****  ....  .*..  ....  ....  ....  ....  0x3f040000u
    // 1     =  .*..  ....  *...  *.**  ***.  ....  *...  *...  0x408be088u
    Q[14] = (rng() & 0x00701f77u) + 0x408be088u + I;

    // Next sufficient conditions until Q[24]:
    // Q[15] =  0111  1101  ....  ..10  00..  ....  ....  0...
    // Q[16] =  ^.10  ....  ....  ..01  1...  ....  ....  1...
    // Q[17] =  ^.v.  ....  ....  ..0.  1...  ....  ....  1...
    // Q[18] =  ^.^.  ....  ....  ..1.  ....  ....  ....  ....
    // Q[19] =  ^...  ....  ....  ..0.  ....  ....  ....  ....
    // Q[20] =  ^...  ....  ....  ..v.  ....  ....  ....  ....
    // Q[21] =  ^...  ....  ....  ..^.  ....  ....  ....  ....
    // Q[22] =  ^...  ....  ....  ....  ....  ....  ....  ....
    // Q[23] =  0...  ....  ....  ....  ....  ....  ....  ....
    // Q[24] =  1...  ....  ....  ....  ....  ....  ....  ....

    // In MMMM-Q[1]/Q[2] we want to change the value of x[0] without updating
    // the value of x[1], as updating x[1] will cause conditions on Q[17] not
    // hold. According to F, if QM0[i] = QM1[i] randomly choose the value where
    // Q[1][i] = Q[2][i] will not change the value of F(Q[1],QM0,QM1). We select
    // these bits
    //  Q[ 1] = ~Ivvv  010v  vv1v  vvv1  .vvv  0vvv  vv0.  ...v
    //  Q[ 2] = ~I^^^  110^  ^^0^  ^^^1  0^^^  1^^^  ^^0v  v00^
    //           0111  0001  1101  1110  0111  0111  1100  0001 = 0x71de77c1u
    //
    // Note that (~(QM0 ^ QM1)) are all the bits where QM0[i] = QM1[i] and so
    // mask_Q1Q2 are all the bits where QM0[i] = QM1[i] and where Q[1][i] =
    // Q[2][i]. These bits will be changed.
    mask_Q1Q2 = (~(QM0 ^ QM1)) & 0x71de77c1u;
    Q1Q2_strength = 0u;
    // Can at most be 19
    for (i = 1u; i < 33u; i++)
      Q1Q2_strength += bit(mask_Q1Q2, i);

    Q1_fix = Q[1] & ~mask_Q1Q2;
    Q2_fix = Q[2] & ~mask_Q1Q2;

    tmp_q1 = Q[1];
    tmp_q2 = Q[2];
    tmp_q4 = Q[4];
    tmp_q9 = Q[9];

    ///////////////////////////////////////////////////////////////
    ///                        MMMM Q16                          //
    ///////////////////////////////////////////////////////////////
    // MMMM Q16 - 25 bits
    /* for (itr_q16 = 0u; itr_q16 < pow2(25 - 16); itr_q16++) { */
    /* for (itr_q16 = 0u; itr_q16 < pow2(25 - 16); itr_q16++) { */
    for (itr_q16 = 0u; itr_q16 < pow2(14); itr_q16++) {
    /* for (itr_q16 = 0u; itr_q16 < pow2(11); itr_q16++) { */

      Q[1] = tmp_q1;
      Q[2] = tmp_q2;
      Q[4] = tmp_q4;
      Q[9] = tmp_q9;

      // Conditions by Liang-Lai says: Q[15] = (rng() & 0x80fc3ff7u) +
      // 0x7d020000u, Q[15] =  0111  1101  ....  ..10  00..  ....  ....  0... RNG
      // =  ....  ....  ****  **..  ..**  ****  ****  .***  0x80fc3ff7u 0     =
      // *...  ..*.  ....  ...*  **..  ....  ....  *...  0x0201c008u 1     = .***
      // **.*  ....  ..*.  ....  ....  ....  ....  0x7d020000u
      Q[15] = (rng() & 0x00fc3ff7u) + 0x7d020000u;

      // Q[16] =  ^.10  ....  ....  ..01  1...  ....  ....  1...
      // RNG   =  .*..  ****  ****  **..  .***  ****  ****  .***  0x4ffc7ff7u
      // 0     =  ...*  ....  ....  ..*.  ....  ....  ....  ....  0x10020000u
      // 1     =  ..*.  ....  ....  ...*  *...  ....  ....  *...  0x20018008u
      // Q[15] =  *.... ..... ..... .... ..... ..... ...... ....  0x80000000u
      Q[16] = (rng() & 0x4ffc7ff7u) + 0x20018008u + (Q[15] & 0x80000000u);

      x[1] = RR(Q[2] - Q[1], 12u) - F(Q[1], QM0, QM1) - QM2 - 0xe8c7b756u;
      x[6] = RR(Q[7] - Q[6], 17u) - F(Q[6], Q[5], Q[4]) - Q[3] - 0xa8304613u;
      x[11] = RR(Q[12] - Q[11], 22u) - F(Q[11], Q[10], Q[9]) - Q[8] - 0x895cd7beu;

      // Q[17] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      // Extra conditions: Σ17,25 ~ Σ17,27 not all 1
      // 0x07000000u =  0000 0111 0000 0000 0000 0000 0000 0000
      sigma_Q17 = G(Q[16], Q[15], Q[14]) + Q[13] + x[1] + 0xf61e2562u;
      if ((sigma_Q17 & 0x07000000u) == 0x07000000u)
        continue;

      // Q[16] =  ^.10  ....  ....  ..01  1...  ....  ....  1...
      // Q[17] =  ^.v.  ....  ....  ..0.  1...  ....  ....  1...
      //          1000  0000  0000  0010  1000  0000  0000  1000 0x80028008u
      Q[17] = Q[16] + RL(sigma_Q17, 5u);

      if ((Q[17] & 0x80028008u) != (Q[16] & 0x80028008u))
        continue;

      // Q[18] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      Q[18] = Q[17] + RL(G(Q[17], Q[16], Q[15]) + Q[14] + x[6] + 0xc040b340u, 9u);

      // Q[18] =  ^.^.  ....  ....  ..1.  ....  ....  ....  ....
      if (bit(Q[18], 18u) != 1u)
        continue;

      if ((Q[18] & 0xa0000000u) != (Q[17] & 0xa0000000u))
        continue;

      // Q[19] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      // Extra conditions: Σ19,4 ~ Σ19,18 not all 1
      // 0x0003fff8u =  0000 0000 0000 0011 1111 1111 1111 1000
      sigma_Q19 = G(Q[18], Q[17], Q[16]) + Q[15] + x[11] + 0x265e5a51u;
      if ((sigma_Q19 & 0x0003fff8u) == 0x0003fff8u)
        continue;

      Q[19] = Q[18] + RL(sigma_Q19, 14u);

      // Q[19] =  ^...  ....  ....  ..0.  ....  ....  ....  ....
      if (bit(Q[19], 18u) != 0u)
        continue;

      if (bit(Q[19], 32u) != bit(Q[18], 32u))
        continue;

      x[10] = RR(Q[11] - Q[10], 17u) - F(Q[10], Q[9], Q[8]) - Q[7] - 0xffff5bb1u;
      x[15] =
          RR(Q[16] - Q[15], 22u) - F(Q[15], Q[14], Q[13]) - Q[12] - 0x49b40821u;

      ///////////////////////////////////////////////////////////////
      ///                      MMMM Q1/Q2                          //
      ///////////////////////////////////////////////////////////////
      // MMMM Q1/Q2 - variable bits
      for (itr_q1q2 = 0u; itr_q1q2 < pow2(Q1Q2_strength); itr_q1q2++) {
      /* for (itr_q1q2 = 0u; itr_q1q2 < pow2(Q1Q2_strength); itr_q1q2++) { */
      /* for (itr_q1q2 = 0u; itr_q1q2 < pow2(1); itr_q1q2++) { */

        Q[4] = tmp_q4;
        Q[9] = tmp_q9;

        // We randomly change the mask bits where QM0[i] = QM1[i] and where
        // Q[1][i] = Q[2][i]
        Q[1] = (rng() & mask_Q1Q2) + Q1_fix;
        Q[2] = (Q[1] & mask_Q1Q2) + Q2_fix;


        x[0] = RR(Q[1] - QM0, 7u) - F(QM0, QM1, QM2) - QM3 - 0xd76aa478u;

        // Q[20] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Extra conditions: Σ20,30 ~ Σ20,32 not all 0
        // 0xe0000000u =  1110 0000 0000 0000 0000 0000 0000 0000
        sigma_Q20 = G(Q[19], Q[18], Q[17]) + Q[16] + x[0] + 0xe9b6c7aau;
        if ((sigma_Q20 & 0xe0000000u) == 0u)
          continue;

        Q[20] = Q[19] + RL(sigma_Q20, 20u);

        // Q[20] =  ^...  ....  ....  ..v.  ....  ....  ....  ....
        if (bit(Q[20], 32u) != bit(Q[19], 32u))
          continue;

        // Q[21] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        x[5] = RR(Q[6] - Q[5], 12u) - F(Q[5], Q[4], Q[3]) - Q[2] - 0x4787c62au;

        Q[21] =
            Q[20] + RL(G(Q[20], Q[19], Q[18]) + Q[17] + x[5] + 0xd62f105du, 5u);

        // Q[21] =  ^...  ....  ....  ..^.  ....  ....  ....  ....
        //          1000  0000  0000  0010  0000  0000  0000  0000 = 0x80020000u
        if ((Q[21] & 0x80020000u) != (Q[20] & 0x80020000u))
          continue;

        // Q[21] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Q[22] =
            Q[21] + RL(G(Q[21], Q[20], Q[19]) + Q[18] + x[10] + 0x2441453u, 9u);

        // Q[22] =  ^...  ....  ....  ....  ....  ....  ....  ....
        if (bit(Q[22], 32u) != bit(Q[21], 32u))
          continue;

        // Q[23] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Extra conditions: Σ23,18 = 0
        sigma_Q23 = G(Q[22], Q[21], Q[20]) + Q[19] + x[15] + 0xd8a1e681u;
        if (bit(sigma_Q23, 18u) != 0u)
          continue;

        Q[23] = Q[22] + RL(sigma_Q23, 14u);

        // Q[23] =  0...  ....  ....  ....  ....  ....  ....  ....
        if (bit(Q[23], 32u) != 0u)
          continue;

        // Q[23] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        x[4] = RR(Q[5] - Q[4], 7u) - F(Q[4], Q[3], Q[2]) - Q[1] - 0xf57c0fafu;

        Q[24] =
            Q[23] + RL(G(Q[23], Q[22], Q[21]) + Q[20] + x[4] + 0xe7d3fbc8u, 20u);

        // Q[24] =  1...  ....  ....  ....  ....  ....  ....  ....
        if (bit(Q[24], 32u) != 1u)
          continue;

        x[2] = RR(Q[3] - Q[2], 17u) - F(Q[2], Q[1], QM0) - QM1 - 0x242070dbu;
        x[13] =
            RR(Q[14] - Q[13], 12u) - F(Q[13], Q[12], Q[11]) - Q[10] - 0xfd987193u;
        x[14] =
            RR(Q[15] - Q[14], 17u) - F(Q[14], Q[13], Q[12]) - Q[11] - 0xa679438eu;

        ///////////////////////////////////////////////////////////////
        ///                         MMMM Q4                          //
        ///////////////////////////////////////////////////////////////
        // MMMM Q4 - 6 bits
        u32 startq4 = id & ((1u << 6) - 1u);
        itr_q4 = startq4;
        /* for (itr_q4 = startq4; itr_q4 <= startq4; itr_q4++) { */


          Q[4] = tmp_q4 ^ mask_Q4[itr_q4];

          x[4] = RR(Q[5] - Q[4], 7u) - F(Q[4], Q[3], Q[2]) - Q[1] - 0xf57c0fafu;

          Q[24] = Q[23] +
                  RL(G(Q[23], Q[22], Q[21]) + Q[20] + x[4] + 0xe7d3fbc8u, 20u);

          // Q[24] =  1...  ....  ....  ....  ....  ....  ....  ....
          if (bit(Q[24], 32u) != 1u)
            continue;

          x[3] = RR(Q[4] - Q[3], 22u) - F(Q[3], Q[2], Q[1]) - QM0 - 0xc1bdceeeu;
          x[7] = RR(Q[8] - Q[7], 22u) - F(Q[7], Q[6], Q[5]) - Q[4] - 0xfd469501u;

          ///////////////////////////////////////////////////////////////
          ///                       Tunnel Q9                          //
          ///////////////////////////////////////////////////////////////
          // Tunnel Q9 - 8 bits
          u32 startq9 = (id >> 6) & ((1u << Q9_strength) - 1u);
          itr_q9 = startq9;
          /* for (itr_q9 = startq9; itr_q9 <= startq9; itr_q9++) { */

            Q[9] = tmp_q9 ^ mask_Q9[USE_B2_Q9 ? itr_q9 : 0u];

            x[8] = RR(Q[9] - Q[8], 7u) - F(Q[8], Q[7], Q[6]) - Q[5] - 0x698098d8u;
            x[9] =
                RR(Q[10] - Q[9], 12u) - F(Q[9], Q[8], Q[7]) - Q[6] - 0x8b44f7afu;
            x[12] = RR(Q[13] - Q[12], 7u) - F(Q[12], Q[11], Q[10]) - Q[9] -
                    0x6b901122u;

            Q[25] = Q[24] +
                    RL(G(Q[24], Q[23], Q[22]) + Q[21] + x[9] + 0x21e1cde6u, 5u);
            Q[26] = Q[25] +
                    RL(G(Q[25], Q[24], Q[23]) + Q[22] + x[14] + 0xc33707d6u, 9u);
            Q[27] = Q[26] +
                    RL(G(Q[26], Q[25], Q[24]) + Q[23] + x[3] + 0xf4d50d87u, 14u);
            Q[28] = Q[27] +
                    RL(G(Q[27], Q[26], Q[25]) + Q[24] + x[8] + 0x455a14edu, 20u);
            Q[29] = Q[28] +
                    RL(G(Q[28], Q[27], Q[26]) + Q[25] + x[13] + 0xa9e3e905u, 5u);
            Q[30] = Q[29] +
                    RL(G(Q[29], Q[28], Q[27]) + Q[26] + x[2] + 0xfcefa3f8u, 9u);
            Q[31] = Q[30] +
                    RL(G(Q[30], Q[29], Q[28]) + Q[27] + x[7] + 0x676f02d9u, 14u);
            Q[32] = Q[31] +
                    RL(G(Q[31], Q[30], Q[29]) + Q[28] + x[12] + 0x8d2a4c8au, 20u);
            Q[33] = Q[32] +
                    RL(H(Q[32], Q[31], Q[30]) + Q[29] + x[5] + 0xfffa3942u, 4u);
            Q[34] = Q[33] +
                    RL(H(Q[33], Q[32], Q[31]) + Q[30] + x[8] + 0x8771f681u, 11u);

            // Extra conditions: Σ35,16 = 1
            sigma_Q35 = H(Q[34], Q[33], Q[32]) + Q[31] + x[11] + 0x6d9d6122u;
            if (bit(sigma_Q35, 16u) != 1u)
              continue;

            Q[35] = Q[34] + RL(sigma_Q35, 16u);

            Q[36] = Q[35] +
                    RL(H(Q[35], Q[34], Q[33]) + Q[32] + x[14] + 0xfde5380cu, 23u);
            Q[37] = Q[36] +
                    RL(H(Q[36], Q[35], Q[34]) + Q[33] + x[1] + 0xa4beea44u, 4u);
            Q[38] = Q[37] +
                    RL(H(Q[37], Q[36], Q[35]) + Q[34] + x[4] + 0x4bdecfa9u, 11u);
            Q[39] = Q[38] +
                    RL(H(Q[38], Q[37], Q[36]) + Q[35] + x[7] + 0xf6bb4b60u, 16u);
            Q[40] = Q[39] +
                    RL(H(Q[39], Q[38], Q[37]) + Q[36] + x[10] + 0xbebfbc70u, 23u);
            Q[41] = Q[40] +
                    RL(H(Q[40], Q[39], Q[38]) + Q[37] + x[13] + 0x289b7ec6u, 4u);
            Q[42] = Q[41] +
                    RL(H(Q[41], Q[40], Q[39]) + Q[38] + x[0] + 0xeaa127fau, 11u);
            Q[43] = Q[42] +
                    RL(H(Q[42], Q[41], Q[40]) + Q[39] + x[3] + 0xd4ef3085u, 16u);
            Q[44] = Q[43] +
                    RL(H(Q[43], Q[42], Q[41]) + Q[40] + x[6] + 0x04881d05u, 23u);
            Q[45] = Q[44] +
                    RL(H(Q[44], Q[43], Q[42]) + Q[41] + x[9] + 0xd9d4d039u, 4u);
            Q[46] = Q[45] +
                    RL(H(Q[45], Q[44], Q[43]) + Q[42] + x[12] + 0xe6db99e5u, 11u);
            Q[47] = Q[46] +
                    RL(H(Q[46], Q[45], Q[44]) + Q[43] + x[15] + 0x1fa27cf8u, 16u);
            Q[48] = Q[47] +
                    RL(H(Q[47], Q[46], Q[45]) + Q[44] + x[2] + 0xc4ac5665u, 23u);

            // Last sufficient conditions
            if (bit(Q[48], 32u) != bit(Q[46], 32u))
              continue;

            Q[49] = Q[48] +
                    RL(I(Q[48], Q[47], Q[46]) + Q[45] + x[0] + 0xf4292244u, 6u);

            if (bit(Q[49], 32u) != bit(Q[47], 32u))
              continue;

            Q[50] = Q[49] +
                    RL(I(Q[49], Q[48], Q[47]) + Q[46] + x[7] + 0x432aff97u, 10u);

            if (bit(Q[50], 32u) != (bit(Q[48], 32u) ^ 1u))
              continue;

            Q[51] = Q[50] +
                    RL(I(Q[50], Q[49], Q[48]) + Q[47] + x[14] + 0xab9423a7u, 15u);

            if (bit(Q[51], 32u) != bit(Q[49], 32u))
              continue;

            Q[52] = Q[51] +
                    RL(I(Q[51], Q[50], Q[49]) + Q[48] + x[5] + 0xfc93a039u, 21u);

            if (bit(Q[52], 32u) != bit(Q[50], 32u))
              continue;

            Q[53] = Q[52] +
                    RL(I(Q[52], Q[51], Q[50]) + Q[49] + x[12] + 0x655b59c3u, 6u);

            if (bit(Q[53], 32u) != bit(Q[51], 32u))
              continue;

            Q[54] = Q[53] +
                    RL(I(Q[53], Q[52], Q[51]) + Q[50] + x[3] + 0x8f0ccc92u, 10u);

            if (bit(Q[54], 32u) != bit(Q[52], 32u))
              continue;

            Q[55] = Q[54] +
                    RL(I(Q[54], Q[53], Q[52]) + Q[51] + x[10] + 0xffeff47du, 15u);

            if (bit(Q[55], 32u) != bit(Q[53], 32u))
              continue;

            Q[56] = Q[55] +
                    RL(I(Q[55], Q[54], Q[53]) + Q[52] + x[1] + 0x85845dd1u, 21u);

            if (bit(Q[56], 32u) != bit(Q[54], 32u))
              continue;

            Q[57] = Q[56] +
                    RL(I(Q[56], Q[55], Q[54]) + Q[53] + x[8] + 0x6fa87e4fu, 6u);

            if (bit(Q[57], 32u) != bit(Q[55], 32u))
              continue;

            Q[58] = Q[57] +
                    RL(I(Q[57], Q[56], Q[55]) + Q[54] + x[15] + 0xfe2ce6e0u, 10u);

            if (bit(Q[58], 32u) != bit(Q[56], 32u))
              continue;

            Q[59] = Q[58] +
                    RL(I(Q[58], Q[57], Q[56]) + Q[55] + x[6] + 0xa3014314u, 15u);

            if (bit(Q[59], 32u) != bit(Q[57], 32u))
              continue;

            Q[60] = Q[59] +
                    RL(I(Q[59], Q[58], Q[57]) + Q[56] + x[13] + 0x4e0811a1u, 21u);

            if (bit(Q[60], 26u) != 0u)
              continue;

            if (bit(Q[60], 32u) != (bit(Q[58], 32u) ^ 1u))
              continue;

            Q[61] = Q[60] +
                    RL(I(Q[60], Q[59], Q[58]) + Q[57] + x[4] + 0xf7537e82u, 6u);

            if (bit(Q[61], 26u) != 1u)
              continue;

            if (bit(Q[61], 32u) != bit(Q[59], 32u))
              continue;

            // Extra conditions: Σ62,16 ~ Σ62,22 not all 0
            // 0x003f8000u =  0000 0000 0011 1111 1000 0000 0000 0000
            sigma_Q62 = I(Q[61], Q[60], Q[59]) + Q[58] + x[11] + 0xbd3af235u;
            if ((sigma_Q62 & 0x003f8000u) == 0u)
              continue;

            Q[62] = Q[61] + RL(sigma_Q62, 10u);

            if (bit(Q[62], 26u) != 1u)
              continue;

            if (bit(Q[62], 32u) != bit(Q[60], 32u))
              continue;

            Q[63] = Q[62] +
                    RL(I(Q[62], Q[61], Q[60]) + Q[59] + x[2] + 0x2ad7d2bbu, 15u);

            if (bit(Q[63], 26u) != 1u)
              continue;

            if (bit(Q[63], 32u) != bit(Q[61], 32u))
              continue;

            Q[64] = Q[63] +
                    RL(I(Q[63], Q[62], Q[61]) + Q[60] + x[9] + 0xeb86d391u, 21u);

            // Condition not necessary (Sasaki), try to remove
            if (bit(Q[64], 26u) != 1u)
              continue;

            // Block 2 is now completed. We verify if the differential path is
            // reached.
            //

            // Message 1 intermediate hash
            AA0 = A0 + Q[61];
            BB0 = B0 + Q[64];
            CC0 = C0 + Q[63];
            DD0 = D0 + Q[62];

            // Message 2 intermediate hash computation
            for (i = 0u; i < 16u; i++){
              Hx[i] = x[i];
            }

            Hx[4] = x[4] - 0x80000000u;
            Hx[11] = x[11] - 0x00008000u;
            Hx[14] = x[14] - 0x80000000u;

            a = A1;
            b = B1;
            c = C1;
            d = D1;

            HMD5Tr();

            AA1 = A1 + a;
            BB1 = B1 + b;
            CC1 = C1 + c;
            DD1 = D1 + d;


            if (((AA1 - AA0) != 0u) || ((BB1 - BB0) != 0u) ||
                ((CC1 - CC0) != 0u) || ((DD1 - DD0) != 0u))
              continue;

            // We have now found a collision!!

            // I save the last intermediate hash for final hash computation
            /* A0 = AA0; */
            /* B0 = BB0; */
            /* C0 = CC0; */
            /* D0 = DD0; */

            /* printf("A0 %u \n", A0); */
            /* printf("Took %d  and %d iterations \n", it, itr_q9); */
            // I save both second blocks
            /* for (i = 0; i < 16; i++) { */
            /*   memcpy(&v1[64 + (i * 4)], &x[i], 4); */
            /*   memcpy(&v2[64 + (i * 4)], &Hx[i], 4); */
            /*   /1* for (int j = 0; j < 4; j++) { *1/ */
            /*   /1*   printf("%u, ", v1[64 + 4 * i + j]); *1/ */
            /*   /1* } *1/ */
            /*   /1* printf("\n"); *1/ */
            /* } */

            tunnel9 = itr_q9;
            tunnel4 = itr_q4;
            /* tunnel14 = itr_Q14; */
            /* tunnel13 = itr_Q13; */
            /* tunnel20 = itr_Q20; */
            /* tunnel10 = itr_Q10; */
            /* tunnel16 = itr_q16; */
            /* tunnelq1q2 = itr_q1q2; */
            return (0);

          /* }    // End of Tunnel Q9 */
        /* }      // End of MMMM Q4 */
      }        // End of MMMM Q1/12
    }          // End of MMMM Q16
  /* }            // End of general for */
  return (-1); // Collision not found
}



void main() {
    pos = ivec2(position * 256.0);
    u32 x = uint(pos.x);
    u32 y = uint(pos.y);
    X = seed;
    u32 id = x + y * 256u;
    if ((id >> 14u) > 0u){
      discard;
    }
    /* int it = -1; */
    int it = Block2(id);
    if (it >= 0) {
      color = return_vec(create_return_from_second_tunnels());
    } else {
      /* color = return_vec(create_return_from_second_tunnels()); */
      discard;
    }
}
